// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: follow.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addFollow = `-- name: AddFollow :one
WITH inserted AS (
  INSERT INTO user_follows (follower_uid, followee_uid)
  VALUES ($1, $2)
  ON CONFLICT DO NOTHING
  RETURNING 1
),
updated_following AS (
  UPDATE users
  SET following_count = following_count + 1
  WHERE uid = $1
    AND EXISTS (SELECT 1 FROM inserted)
  RETURNING following_count
),
updated_followers AS (
  UPDATE users
  SET followers_count = followers_count + 1
  WHERE uid = $2
    AND EXISTS (SELECT 1 FROM inserted)
  RETURNING followers_count
)
SELECT
  COALESCE(
    (SELECT following_count FROM updated_following),
    (SELECT following_count FROM users WHERE users.uid = $1)
  )::int4 AS following_count,
  COALESCE(
    (SELECT followers_count FROM updated_followers),
    (SELECT followers_count FROM users WHERE users.uid = $2)
  )::int4 AS followers_count
`

type AddFollowParams struct {
	FollowerUid uuid.UUID
	FolloweeUid uuid.UUID
}

type AddFollowRow struct {
	FollowingCount int32
	FollowersCount int32
}

func (q *Queries) AddFollow(ctx context.Context, arg AddFollowParams) (AddFollowRow, error) {
	row := q.db.QueryRowContext(ctx, addFollow, arg.FollowerUid, arg.FolloweeUid)
	var i AddFollowRow
	err := row.Scan(&i.FollowingCount, &i.FollowersCount)
	return i, err
}

const isFollowing = `-- name: IsFollowing :one
SELECT EXISTS(
  SELECT 1
  FROM user_follows
  WHERE follower_uid = $1
    AND followee_uid = $2
) AS is_following
`

type IsFollowingParams struct {
	FollowerUid uuid.UUID
	FolloweeUid uuid.UUID
}

func (q *Queries) IsFollowing(ctx context.Context, arg IsFollowingParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isFollowing, arg.FollowerUid, arg.FolloweeUid)
	var is_following bool
	err := row.Scan(&is_following)
	return is_following, err
}

const listFollowers = `-- name: ListFollowers :many
SELECT uf.created_at AS followed_at,
  u.uid,
  u.role,
  u.nickname,
  u.avatar_url,
  u.followers_count,
  u.following_count,
  u.status,
  u.created_at
FROM user_follows uf
  JOIN users u ON u.uid = uf.follower_uid
  AND u.status = 'NORMAL'::user_status
WHERE uf.followee_uid = $1
  AND (
    (
      $2::timestamptz IS NULL
      AND $3::uuid IS NULL
    )
    OR (uf.created_at, uf.follower_uid) < (
      $2::timestamptz,
      $3::uuid
    )
  )
ORDER BY uf.created_at DESC,
  uf.follower_uid DESC
LIMIT 20
`

type ListFollowersParams struct {
	Uid             uuid.UUID
	CursorCreatedAt sql.NullTime
	CursorID        uuid.NullUUID
}

type ListFollowersRow struct {
	FollowedAt     time.Time
	Uid            uuid.UUID
	Role           UserRole
	Nickname       string
	AvatarUrl      string
	FollowersCount int32
	FollowingCount int32
	Status         UserStatus
	CreatedAt      time.Time
}

func (q *Queries) ListFollowers(ctx context.Context, arg ListFollowersParams) ([]ListFollowersRow, error) {
	rows, err := q.db.QueryContext(ctx, listFollowers, arg.Uid, arg.CursorCreatedAt, arg.CursorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFollowersRow
	for rows.Next() {
		var i ListFollowersRow
		if err := rows.Scan(
			&i.FollowedAt,
			&i.Uid,
			&i.Role,
			&i.Nickname,
			&i.AvatarUrl,
			&i.FollowersCount,
			&i.FollowingCount,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFollowing = `-- name: ListFollowing :many
SELECT uf.created_at AS followed_at,
  u.uid,
  u.role,
  u.nickname,
  u.avatar_url,
  u.followers_count,
  u.following_count,
  u.status,
  u.created_at
FROM user_follows uf
  JOIN users u ON u.uid = uf.followee_uid
  AND u.status = 'NORMAL'::user_status
WHERE uf.follower_uid = $1
  AND (
    (
      $2::timestamptz IS NULL
      AND $3::uuid IS NULL
    )
    OR (uf.created_at, uf.followee_uid) < (
      $2::timestamptz,
      $3::uuid
    )
  )
ORDER BY uf.created_at DESC,
  uf.followee_uid DESC
LIMIT 20
`

type ListFollowingParams struct {
	Uid             uuid.UUID
	CursorCreatedAt sql.NullTime
	CursorID        uuid.NullUUID
}

type ListFollowingRow struct {
	FollowedAt     time.Time
	Uid            uuid.UUID
	Role           UserRole
	Nickname       string
	AvatarUrl      string
	FollowersCount int32
	FollowingCount int32
	Status         UserStatus
	CreatedAt      time.Time
}

func (q *Queries) ListFollowing(ctx context.Context, arg ListFollowingParams) ([]ListFollowingRow, error) {
	rows, err := q.db.QueryContext(ctx, listFollowing, arg.Uid, arg.CursorCreatedAt, arg.CursorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFollowingRow
	for rows.Next() {
		var i ListFollowingRow
		if err := rows.Scan(
			&i.FollowedAt,
			&i.Uid,
			&i.Role,
			&i.Nickname,
			&i.AvatarUrl,
			&i.FollowersCount,
			&i.FollowingCount,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeFollow = `-- name: RemoveFollow :one
WITH deleted AS (
  DELETE FROM user_follows
  WHERE follower_uid = $1
    AND followee_uid = $2
  RETURNING 1
),
updated_following AS (
  UPDATE users
  SET following_count = GREATEST(following_count - 1, 0)
  WHERE uid = $1
    AND EXISTS (SELECT 1 FROM deleted)
  RETURNING following_count
),
updated_followers AS (
  UPDATE users
  SET followers_count = GREATEST(followers_count - 1, 0)
  WHERE uid = $2
    AND EXISTS (SELECT 1 FROM deleted)
  RETURNING followers_count
)
SELECT
  COALESCE(
    (SELECT following_count FROM updated_following),
    (SELECT following_count FROM users WHERE users.uid = $1)
  )::int4 AS following_count,
  COALESCE(
    (SELECT followers_count FROM updated_followers),
    (SELECT followers_count FROM users WHERE users.uid = $2)
  )::int4 AS followers_count
`

type RemoveFollowParams struct {
	FollowerUid uuid.UUID
	FolloweeUid uuid.UUID
}

type RemoveFollowRow struct {
	FollowingCount int32
	FollowersCount int32
}

func (q *Queries) RemoveFollow(ctx context.Context, arg RemoveFollowParams) (RemoveFollowRow, error) {
	row := q.db.QueryRowContext(ctx, removeFollow, arg.FollowerUid, arg.FolloweeUid)
	var i RemoveFollowRow
	err := row.Scan(&i.FollowingCount, &i.FollowersCount)
	return i, err
}
