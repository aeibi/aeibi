// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: post.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const archivePostByUidAndAuthor = `-- name: ArchivePostByUidAndAuthor :execrows
UPDATE posts
SET status = 'ARCHIVED'::post_status,
  updated_at = now()
WHERE uid = $1
  AND author = $2
  AND status = 'NORMAL'::post_status
`

type ArchivePostByUidAndAuthorParams struct {
	Uid    uuid.UUID
	Author uuid.UUID
}

func (q *Queries) ArchivePostByUidAndAuthor(ctx context.Context, arg ArchivePostByUidAndAuthorParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, archivePostByUidAndAuthor, arg.Uid, arg.Author)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
    author,
    text,
    images,
    attachments,
    visibility,
    pinned,
    ip
  )
VALUES (
    $1,
    $2,
    COALESCE($3::text [], '{}'::text []),
    COALESCE($4::text [], '{}'::text []),
    $5,
    $6,
    $7
  )
RETURNING id,
  uid
`

type CreatePostParams struct {
	Author      uuid.UUID
	Text        string
	Images      []string
	Attachments []string
	Visibility  PostVisibility
	Pinned      bool
	Ip          string
}

type CreatePostRow struct {
	ID  int32
	Uid uuid.UUID
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (CreatePostRow, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.Author,
		arg.Text,
		pq.Array(arg.Images),
		pq.Array(arg.Attachments),
		arg.Visibility,
		arg.Pinned,
		arg.Ip,
	)
	var i CreatePostRow
	err := row.Scan(&i.ID, &i.Uid)
	return i, err
}

const getPostByUid = `-- name: GetPostByUid :one
SELECT p.uid,
  p.author,
  u.uid AS author_uid,
  u.nickname AS author_nickname,
  u.avatar_url AS author_avatar_url,
  p.text,
  p.images,
  p.attachments,
  p.comment_count,
  p.collection_count,
  p.like_count,
  p.pinned,
  p.visibility,
  p.latest_replied_on,
  p.ip,
  p.status,
  p.created_at,
  p.updated_at,
  (pl.user_uid IS NOT NULL)::boolean AS liked,
  (pc.user_uid IS NOT NULL)::boolean AS collected,
  COALESCE(
    (
      SELECT array_agg(
          t.name
          ORDER BY t.name
        )
      FROM post_tags pt
        JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
    ),
    '{}'::text []
  )::text [] AS tag_names
FROM posts p
  JOIN users u ON u.uid = p.author
  AND u.status = 'NORMAL'::user_status
  LEFT JOIN post_likes pl ON pl.post_uid = p.uid
  AND pl.user_uid = $1::uuid
  LEFT JOIN post_collections pc ON pc.post_uid = p.uid
  AND pc.user_uid = $1::uuid
WHERE p.uid = $2
LIMIT 1
`

type GetPostByUidParams struct {
	Viewer uuid.NullUUID
	Uid    uuid.UUID
}

type GetPostByUidRow struct {
	Uid             uuid.UUID
	Author          uuid.UUID
	AuthorUid       uuid.UUID
	AuthorNickname  string
	AuthorAvatarUrl string
	Text            string
	Images          []string
	Attachments     []string
	CommentCount    int32
	CollectionCount int32
	LikeCount       int32
	Pinned          bool
	Visibility      PostVisibility
	LatestRepliedOn time.Time
	Ip              string
	Status          PostStatus
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Liked           bool
	Collected       bool
	TagNames        []string
}

func (q *Queries) GetPostByUid(ctx context.Context, arg GetPostByUidParams) (GetPostByUidRow, error) {
	row := q.db.QueryRowContext(ctx, getPostByUid, arg.Viewer, arg.Uid)
	var i GetPostByUidRow
	err := row.Scan(
		&i.Uid,
		&i.Author,
		&i.AuthorUid,
		&i.AuthorNickname,
		&i.AuthorAvatarUrl,
		&i.Text,
		pq.Array(&i.Images),
		pq.Array(&i.Attachments),
		&i.CommentCount,
		&i.CollectionCount,
		&i.LikeCount,
		&i.Pinned,
		&i.Visibility,
		&i.LatestRepliedOn,
		&i.Ip,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Liked,
		&i.Collected,
		pq.Array(&i.TagNames),
	)
	return i, err
}

const listPosts = `-- name: ListPosts :many
SELECT p.uid,
  p.author,
  u.uid AS author_uid,
  u.nickname AS author_nickname,
  u.avatar_url AS author_avatar_url,
  p.text,
  p.images,
  p.attachments,
  p.comment_count,
  p.collection_count,
  p.like_count,
  p.pinned,
  p.visibility,
  p.latest_replied_on,
  p.ip,
  p.status,
  p.created_at,
  p.updated_at,
  (pl.user_uid IS NOT NULL)::boolean AS liked,
  (pc.user_uid IS NOT NULL)::boolean AS collected,
  COALESCE(
    (
      SELECT array_agg(
          t.name
          ORDER BY t.name
        )
      FROM post_tags pt
        JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
    ),
    '{}'::text []
  )::text [] AS tag_names
FROM posts p
  JOIN users u ON u.uid = p.author
  AND u.status = 'NORMAL'::user_status
  LEFT JOIN post_likes pl ON pl.post_uid = p.uid
  AND pl.user_uid = $1::uuid
  LEFT JOIN post_collections pc ON pc.post_uid = p.uid
  AND pc.user_uid = $1::uuid
WHERE p.status = 'NORMAL'::post_status
  AND (
    (
      $2::timestamptz IS NULL
      AND $3::uuid IS NULL
    )
    OR (p.created_at, p.uid) < (
      $2::timestamptz,
      $3::uuid
    )
  )
ORDER BY p.created_at DESC,
  p.uid DESC
LIMIT 20
`

type ListPostsParams struct {
	Viewer          uuid.NullUUID
	CursorCreatedAt sql.NullTime
	CursorID        uuid.NullUUID
}

type ListPostsRow struct {
	Uid             uuid.UUID
	Author          uuid.UUID
	AuthorUid       uuid.UUID
	AuthorNickname  string
	AuthorAvatarUrl string
	Text            string
	Images          []string
	Attachments     []string
	CommentCount    int32
	CollectionCount int32
	LikeCount       int32
	Pinned          bool
	Visibility      PostVisibility
	LatestRepliedOn time.Time
	Ip              string
	Status          PostStatus
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Liked           bool
	Collected       bool
	TagNames        []string
}

func (q *Queries) ListPosts(ctx context.Context, arg ListPostsParams) ([]ListPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, listPosts, arg.Viewer, arg.CursorCreatedAt, arg.CursorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsRow
	for rows.Next() {
		var i ListPostsRow
		if err := rows.Scan(
			&i.Uid,
			&i.Author,
			&i.AuthorUid,
			&i.AuthorNickname,
			&i.AuthorAvatarUrl,
			&i.Text,
			pq.Array(&i.Images),
			pq.Array(&i.Attachments),
			&i.CommentCount,
			&i.CollectionCount,
			&i.LikeCount,
			&i.Pinned,
			&i.Visibility,
			&i.LatestRepliedOn,
			&i.Ip,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Liked,
			&i.Collected,
			pq.Array(&i.TagNames),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsByAuthor = `-- name: ListPostsByAuthor :many
SELECT p.uid,
  p.author,
  u.uid AS author_uid,
  u.nickname AS author_nickname,
  u.avatar_url AS author_avatar_url,
  p.text,
  p.images,
  p.attachments,
  p.comment_count,
  p.collection_count,
  p.like_count,
  p.pinned,
  p.visibility,
  p.latest_replied_on,
  p.ip,
  p.status,
  p.created_at,
  p.updated_at,
  (pl.user_uid IS NOT NULL)::boolean AS liked,
  (pc.user_uid IS NOT NULL)::boolean AS collected,
  COALESCE(
    (
      SELECT array_agg(
          t.name
          ORDER BY t.name
        )
      FROM post_tags pt
        JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
    ),
    '{}'::text []
  )::text [] AS tag_names
FROM posts p
  JOIN users u ON u.uid = p.author
  AND u.status = 'NORMAL'::user_status
  LEFT JOIN post_likes pl ON pl.post_uid = p.uid
  AND pl.user_uid = $1::uuid
  LEFT JOIN post_collections pc ON pc.post_uid = p.uid
  AND pc.user_uid = $1::uuid
WHERE p.status = 'NORMAL'::post_status
  AND p.author = $2
  AND (
    (
      $3::timestamptz IS NULL
      AND $4::uuid IS NULL
    )
    OR (p.created_at, p.uid) < (
      $3::timestamptz,
      $4::uuid
    )
  )
ORDER BY p.created_at DESC,
  p.uid DESC
LIMIT 20
`

type ListPostsByAuthorParams struct {
	Viewer          uuid.NullUUID
	Author          uuid.UUID
	CursorCreatedAt sql.NullTime
	CursorID        uuid.NullUUID
}

type ListPostsByAuthorRow struct {
	Uid             uuid.UUID
	Author          uuid.UUID
	AuthorUid       uuid.UUID
	AuthorNickname  string
	AuthorAvatarUrl string
	Text            string
	Images          []string
	Attachments     []string
	CommentCount    int32
	CollectionCount int32
	LikeCount       int32
	Pinned          bool
	Visibility      PostVisibility
	LatestRepliedOn time.Time
	Ip              string
	Status          PostStatus
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Liked           bool
	Collected       bool
	TagNames        []string
}

func (q *Queries) ListPostsByAuthor(ctx context.Context, arg ListPostsByAuthorParams) ([]ListPostsByAuthorRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByAuthor,
		arg.Viewer,
		arg.Author,
		arg.CursorCreatedAt,
		arg.CursorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsByAuthorRow
	for rows.Next() {
		var i ListPostsByAuthorRow
		if err := rows.Scan(
			&i.Uid,
			&i.Author,
			&i.AuthorUid,
			&i.AuthorNickname,
			&i.AuthorAvatarUrl,
			&i.Text,
			pq.Array(&i.Images),
			pq.Array(&i.Attachments),
			&i.CommentCount,
			&i.CollectionCount,
			&i.LikeCount,
			&i.Pinned,
			&i.Visibility,
			&i.LatestRepliedOn,
			&i.Ip,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Liked,
			&i.Collected,
			pq.Array(&i.TagNames),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePostByUidAndAuthor = `-- name: UpdatePostByUidAndAuthor :one
UPDATE posts
SET text = COALESCE($1, text),
  images = COALESCE($2::text [], images),
  attachments = COALESCE($3::text [], attachments),
  visibility = COALESCE(
    $4::post_visibility,
    visibility
  ),
  pinned = COALESCE($5::boolean, pinned),
  updated_at = now()
WHERE uid = $6
  AND author = $7
  AND status = 'NORMAL'::post_status
RETURNING id
`

type UpdatePostByUidAndAuthorParams struct {
	Text        sql.NullString
	Images      []string
	Attachments []string
	Visibility  NullPostVisibility
	Pinned      sql.NullBool
	Uid         uuid.UUID
	Author      uuid.UUID
}

func (q *Queries) UpdatePostByUidAndAuthor(ctx context.Context, arg UpdatePostByUidAndAuthorParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, updatePostByUidAndAuthor,
		arg.Text,
		pq.Array(arg.Images),
		pq.Array(arg.Attachments),
		arg.Visibility,
		arg.Pinned,
		arg.Uid,
		arg.Author,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const upsertPostTags = `-- name: UpsertPostTags :exec
WITH input AS (
  SELECT DISTINCT unnest($2::text []) AS name
),
upsert AS (
  INSERT INTO tags(name)
  SELECT name
  FROM input ON CONFLICT (name) DO
  UPDATE
  SET name = EXCLUDED.name
  RETURNING id
),
new_ids AS (
  SELECT id AS tag_id
  FROM upsert
),
del AS (
  DELETE FROM post_tags pt
  WHERE pt.post_id = $1
    AND NOT EXISTS (
      SELECT 1
      FROM new_ids n
      WHERE n.tag_id = pt.tag_id
    )
)
INSERT INTO post_tags (post_id, tag_id)
SELECT $1,
  tag_id
FROM new_ids ON CONFLICT (post_id, tag_id) DO NOTHING
`

type UpsertPostTagsParams struct {
	PostID int32
	Tags   []string
}

func (q *Queries) UpsertPostTags(ctx context.Context, arg UpsertPostTagsParams) error {
	_, err := q.db.ExecContext(ctx, upsertPostTags, arg.PostID, pq.Array(arg.Tags))
	return err
}
