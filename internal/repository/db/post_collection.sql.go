// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: post_collection.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addPostCollection = `-- name: AddPostCollection :one
WITH inserted AS (
  INSERT INTO post_collections (post_uid, user_uid)
  VALUES ($1, $2)
  ON CONFLICT DO NOTHING
  RETURNING 1
),
updated AS (
  UPDATE posts
  SET collection_count = collection_count + 1,
    updated_at = now()
  WHERE uid = $1
    AND EXISTS (SELECT 1 FROM inserted)
  RETURNING collection_count
)
SELECT collection_count::int4
FROM updated
UNION ALL
SELECT collection_count::int4
FROM posts
WHERE uid = $1
  AND NOT EXISTS (SELECT 1 FROM updated)
LIMIT 1
`

type AddPostCollectionParams struct {
	PostUid uuid.UUID
	UserUid uuid.UUID
}

func (q *Queries) AddPostCollection(ctx context.Context, arg AddPostCollectionParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, addPostCollection, arg.PostUid, arg.UserUid)
	var collection_count int32
	err := row.Scan(&collection_count)
	return collection_count, err
}

const listPostsByCollector = `-- name: ListPostsByCollector :many
SELECT p.uid,
  p.author,
  u.uid AS author_uid,
  u.nickname AS author_nickname,
  u.avatar_url AS author_avatar_url,
  p.text,
  p.images,
  p.attachments,
  p.comment_count,
  p.collection_count,
  p.like_count,
  p.pinned,
  p.visibility,
  p.latest_replied_on,
  p.ip,
  p.status,
  p.created_at,
  p.updated_at,
  COALESCE(
    (
      SELECT array_agg(
          t.name
          ORDER BY t.name
        )
      FROM post_tags pt
        JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
    ),
    '{}'::text []
  )::text [] AS tag_names
FROM post_collections pc
  JOIN posts p ON p.uid = pc.post_uid
  JOIN users u ON u.uid = p.author
  AND u.status = 'NORMAL'::user_status
WHERE p.status = 'NORMAL'::post_status
  AND pc.user_uid = $1
  AND (
    p.visibility = 'PUBLIC'::post_visibility
    OR p.author = $1
  )
  AND (
    (
      $2::timestamptz IS NULL
      AND $3::uuid IS NULL
    )
    OR (p.created_at, p.uid) < (
      $2::timestamptz,
      $3::uuid
    )
  )
ORDER BY p.created_at DESC,
  p.uid DESC
LIMIT 20
`

type ListPostsByCollectorParams struct {
	Collector       uuid.UUID
	CursorCreatedAt sql.NullTime
	CursorID        uuid.NullUUID
}

type ListPostsByCollectorRow struct {
	Uid             uuid.UUID
	Author          uuid.UUID
	AuthorUid       uuid.UUID
	AuthorNickname  string
	AuthorAvatarUrl string
	Text            string
	Images          []string
	Attachments     []string
	CommentCount    int32
	CollectionCount int32
	LikeCount       int32
	Pinned          bool
	Visibility      PostVisibility
	LatestRepliedOn time.Time
	Ip              string
	Status          PostStatus
	CreatedAt       time.Time
	UpdatedAt       time.Time
	TagNames        []string
}

func (q *Queries) ListPostsByCollector(ctx context.Context, arg ListPostsByCollectorParams) ([]ListPostsByCollectorRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByCollector, arg.Collector, arg.CursorCreatedAt, arg.CursorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsByCollectorRow
	for rows.Next() {
		var i ListPostsByCollectorRow
		if err := rows.Scan(
			&i.Uid,
			&i.Author,
			&i.AuthorUid,
			&i.AuthorNickname,
			&i.AuthorAvatarUrl,
			&i.Text,
			pq.Array(&i.Images),
			pq.Array(&i.Attachments),
			&i.CommentCount,
			&i.CollectionCount,
			&i.LikeCount,
			&i.Pinned,
			&i.Visibility,
			&i.LatestRepliedOn,
			&i.Ip,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			pq.Array(&i.TagNames),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePostCollection = `-- name: RemovePostCollection :one
WITH deleted AS (
  DELETE FROM post_collections
  WHERE post_uid = $1
    AND user_uid = $2
  RETURNING 1
),
updated AS (
  UPDATE posts
  SET collection_count = GREATEST(collection_count - 1, 0),
    updated_at = now()
  WHERE uid = $1
    AND EXISTS (SELECT 1 FROM deleted)
  RETURNING collection_count
)
SELECT collection_count::int4
FROM updated
UNION ALL
SELECT collection_count::int4
FROM posts
WHERE uid = $1
  AND NOT EXISTS (SELECT 1 FROM updated)
LIMIT 1
`

type RemovePostCollectionParams struct {
	PostUid uuid.UUID
	UserUid uuid.UUID
}

func (q *Queries) RemovePostCollection(ctx context.Context, arg RemovePostCollectionParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, removePostCollection, arg.PostUid, arg.UserUid)
	var collection_count int32
	err := row.Scan(&collection_count)
	return collection_count, err
}
