// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: post_like.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addPostLike = `-- name: AddPostLike :one
WITH inserted AS (
  INSERT INTO post_likes (post_uid, user_uid)
  VALUES ($1, $2) ON CONFLICT DO NOTHING
  RETURNING 1
),
updated AS (
  UPDATE posts
  SET like_count = like_count + 1,
    updated_at = now()
  WHERE uid = $1
    AND EXISTS (SELECT 1 FROM inserted)
  RETURNING like_count
)
SELECT like_count
FROM updated
UNION ALL
SELECT like_count
FROM posts
WHERE uid = $1
  AND NOT EXISTS (SELECT 1 FROM updated)
LIMIT 1
`

type AddPostLikeParams struct {
	PostUid uuid.UUID
	UserUid uuid.UUID
}

func (q *Queries) AddPostLike(ctx context.Context, arg AddPostLikeParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, addPostLike, arg.PostUid, arg.UserUid)
	var like_count int32
	err := row.Scan(&like_count)
	return like_count, err
}

const listPostsByLiker = `-- name: ListPostsByLiker :many
SELECT p.uid,
  p.author,
  u.uid AS author_uid,
  u.nickname AS author_nickname,
  u.avatar_url AS author_avatar_url,
  p.text,
  p.images,
  p.attachments,
  p.comment_count,
  p.collection_count,
  p.like_count,
  p.pinned,
  p.visibility,
  p.latest_replied_on,
  p.ip,
  p.status,
  p.created_at,
  p.updated_at,
  true AS liked,
  (c.user_uid IS NOT NULL)::boolean AS collected,
  COALESCE(
    (
      SELECT array_agg(
          t.name
          ORDER BY t.name
        )
      FROM post_tags pt
        JOIN tags t ON t.id = pt.tag_id
      WHERE pt.post_id = p.id
    ),
    '{}'::text []
  )::text [] AS tag_names
FROM post_likes l
  JOIN posts p ON p.uid = l.post_uid
  JOIN users u ON u.uid = p.author
  AND u.status = 'NORMAL'::user_status
  LEFT JOIN post_collections c ON c.post_uid = p.uid
  AND c.user_uid = $1
WHERE p.status = 'NORMAL'::post_status
  AND l.user_uid = $1
  AND (
    p.visibility = 'PUBLIC'::post_visibility
    OR p.author = $1
  )
  AND (
    (
      $2::timestamptz IS NULL
      AND $3::uuid IS NULL
    )
    OR (p.created_at, p.uid) < (
      $2::timestamptz,
      $3::uuid
    )
  )
ORDER BY p.created_at DESC,
  p.uid DESC
LIMIT 20
`

type ListPostsByLikerParams struct {
	Liker           uuid.UUID
	CursorCreatedAt sql.NullTime
	CursorID        uuid.NullUUID
}

type ListPostsByLikerRow struct {
	Uid             uuid.UUID
	Author          uuid.UUID
	AuthorUid       uuid.UUID
	AuthorNickname  string
	AuthorAvatarUrl string
	Text            string
	Images          []string
	Attachments     []string
	CommentCount    int32
	CollectionCount int32
	LikeCount       int32
	Pinned          bool
	Visibility      PostVisibility
	LatestRepliedOn time.Time
	Ip              string
	Status          PostStatus
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Liked           bool
	Collected       bool
	TagNames        []string
}

func (q *Queries) ListPostsByLiker(ctx context.Context, arg ListPostsByLikerParams) ([]ListPostsByLikerRow, error) {
	rows, err := q.db.QueryContext(ctx, listPostsByLiker, arg.Liker, arg.CursorCreatedAt, arg.CursorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsByLikerRow
	for rows.Next() {
		var i ListPostsByLikerRow
		if err := rows.Scan(
			&i.Uid,
			&i.Author,
			&i.AuthorUid,
			&i.AuthorNickname,
			&i.AuthorAvatarUrl,
			&i.Text,
			pq.Array(&i.Images),
			pq.Array(&i.Attachments),
			&i.CommentCount,
			&i.CollectionCount,
			&i.LikeCount,
			&i.Pinned,
			&i.Visibility,
			&i.LatestRepliedOn,
			&i.Ip,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Liked,
			&i.Collected,
			pq.Array(&i.TagNames),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePostLike = `-- name: RemovePostLike :one
WITH deleted AS (
  DELETE FROM post_likes
  WHERE post_uid = $1
    AND user_uid = $2
  RETURNING 1
),
updated AS (
  UPDATE posts
  SET like_count = GREATEST(like_count - 1, 0),
    updated_at = now()
  WHERE uid = $1
    AND EXISTS (SELECT 1 FROM deleted)
  RETURNING like_count
)
SELECT like_count
FROM updated
UNION ALL
SELECT like_count
FROM posts
WHERE uid = $1
  AND NOT EXISTS (SELECT 1 FROM updated)
LIMIT 1
`

type RemovePostLikeParams struct {
	PostUid uuid.UUID
	UserUid uuid.UUID
}

func (q *Queries) RemovePostLike(ctx context.Context, arg RemovePostLikeParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, removePostLike, arg.PostUid, arg.UserUid)
	var like_count int32
	err := row.Scan(&like_count)
	return like_count, err
}
